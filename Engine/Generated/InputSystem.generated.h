//Autogenerated at 2025-12-03 20:30:43.856866
#pragma once
#include <typeinfo>
#include <memory>
#include "Instance/Reflection.h"

class System;
namespace Reflection {
	inline ::Instance* instantiate_InputSystem(Engine* engine);
	inline ::std::shared_ptr<::Instance> instantiateShared_InputSystem(Engine* engine);


	//Class runtime reflection data
	inline static Class reflected_InputSystem = {
		//Class name
		"InputSystem",
		//Class hash id
		7282256069168611396,
		{
			//	Name, Type, Id, Flags, TypeFlags, Setter, Getter
			{ "FocusedInstance", "IInputFocusable*", 18351347418680230395, DefaultPropFlags, PropTypeFlags::None, AccessLevel::Public, Lua::StateContext::Client, nullptr, nullptr }
		},
		{
			//events
			{ "InputBegan", {{ "Input*", "???" }}, 13115654874339676767, AccessLevel::Public, Lua::StateContext::Client },
			{ "InputChanged", {{ "Input*", "???" }}, 5348466406629671574, AccessLevel::Public, Lua::StateContext::Client },
			{ "InputEnded", {{ "Input*", "???" }}, 16688912565138216238, AccessLevel::Public, Lua::StateContext::Client },
			{ "TextEntered", {{ "std::string", "???" }}, 15624128827046837132, AccessLevel::Public, Lua::StateContext::Client }
		},
		{
			//methods

		},
		::std::function<::Instance * (Engine*)>(&instantiate_InputSystem),
		::std::function<::std::shared_ptr<::Instance>(Engine*)>(&instantiateShared_InputSystem),
		{
			//public base classes
15348723867526545374Ui64
		},
		{
			//protected base classes

		},
		{
			//private base classes
12714158115629022154Ui64
		},
		{
			//derived classes

		}
	};
}

#undef REFLECTION

//Class body macro (contains property hash ids)
#define REFLECTION() \
	using Base = System; \
public:\
	const static std::string& ClassName() { \
		static std::string _className = "InputSystem"; \
		return _className; \
	} \
	static Reflection::Class& StaticClass() { \
		 return Reflection::reflected_InputSystem; \
	} \
	struct ClassRegistrar { \
		template<typename T> \
		ClassRegistrar(T* inst) { \
			Reflection::TrySetClass(inst, &StaticClass()); \
		} \
	} _classRegistrar{this}; \
public: \
	static constexpr uint64_t prop_FocusedInstance = 18351347418680230395Ui64; \
	static constexpr uint64_t event_InputBegan = 13115654874339676767Ui64; \
	static constexpr uint64_t event_InputChanged = 5348466406629671574Ui64; \
	static constexpr uint64_t event_InputEnded = 16688912565138216238Ui64; \
	static constexpr uint64_t event_TextEntered = 15624128827046837132Ui64; \
	static constexpr uint64_t method_Focus = 12528123237184744289Ui64; \
	static constexpr uint64_t method_ClearFocus = 10297588328162760552Ui64; \
	static constexpr uint64_t method_IsKeyDown = 16192639306382548402Ui64; \
	static constexpr uint64_t method_ProcessInput = 3688581774208981920Ui64; \
	static constexpr uint64_t method_ProcessTextInput = 14198425656999138777Ui64; \
 \
	void raisePropChanged(uint64_t propId) { \
		PropertyChanged.Fire(propId); \
		if (LuaPropertyChanged.HasAnyListeners()) { \
			const std::string& propName = StaticClass().GetPropName(propId); \
			LuaPropertyChanged.Fire(propName); \
		} \
	} \
private: \

#undef REFLECTION_END

//Macro that goes after the class definition, at the end of any header with reflected objects.
#define REFLECTION_END() \
namespace Reflection { \
	inline void wrap_InputSystem_SetFocusedInstance(void* obj, void* value) { reinterpret_cast<InputSystem*>(obj)->FocusedInstance = *reinterpret_cast<IInputFocusable**>(value); } \
	inline void* wrap_InputSystem_GetFocusedInstance(void* obj) { IInputFocusable** value = &(reinterpret_cast<InputSystem*>(obj)->FocusedInstance); return reinterpret_cast<void*>(value); } \
 \
	inline void register_InputSystem() { \
		Reflection::registry.classes["InputSystem"] = &Reflection::reflected_InputSystem; \
		Reflection::registry.classesById[7282256069168611396] = &Reflection::reflected_InputSystem; \
		reflected_InputSystem.ResolvePropSetter(InputSystem::prop_FocusedInstance, &wrap_InputSystem_SetFocusedInstance); \
		reflected_InputSystem.ResolvePropGetter(InputSystem::prop_FocusedInstance, &wrap_InputSystem_GetFocusedInstance); \
 \
	} \
	inline ::Instance* instantiate_InputSystem(Engine* engine) { \
		return (::Instance*)new InputSystem(engine); \
	} \
	inline ::std::shared_ptr<::Instance> instantiateShared_InputSystem(Engine* engine) { \
		return ::std::static_pointer_cast<::Instance>(::std::make_shared<InputSystem>(engine)); \
	} \
} \

