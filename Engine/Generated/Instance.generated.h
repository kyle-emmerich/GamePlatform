//Autogenerated at 2025-12-11 17:55:02.704083
#pragma once
#include <typeinfo>
#include <memory>
#include <stdexcept>
#include "Instance/Reflection.h"

class System;
class Instance;
class Engine;


namespace Reflection {
	inline Instance* instantiate_Instance(Engine* engine);
	inline ::std::shared_ptr<Instance> instantiateShared_Instance(Engine* engine);


	//Class runtime reflection data
	inline static Class reflected_Instance = {
		//Class name
		"Instance",
		//Class hash id
		152245926312174492,
		{
			//	Name, Type, Id, Flags, TypeFlags, Setter, Getter
			{ "Id", "EngineUUID", 9675371895780238136, PropFlags::Hidden | PropFlags::ReadOnly | PropFlags::Replicated, PropTypeFlags::None, AccessLevel::Public, Lua::StateContext::Client, nullptr, nullptr },
			{ "Archivable", "bool", 14317038659104216526, PropFlags::Replicated, PropTypeFlags::None, AccessLevel::Public, Lua::StateContext::Client, nullptr, nullptr },
			{ "Name", "std::string", 15240050715179114350, PropFlags::Replicated, PropTypeFlags::None, AccessLevel::Public, Lua::StateContext::Client, nullptr, nullptr },
			{ "Parent", "Instance*", 14850803764360279445, PropFlags::Replicated, PropTypeFlags::None, AccessLevel::Public, Lua::StateContext::Client, nullptr, nullptr },
			{ "Children", "std::vector<Instance*>", 9730800845107737082, PropFlags::ReadOnly, PropTypeFlags::None, AccessLevel::Public, Lua::StateContext::Client, nullptr, nullptr }
		},
		{
			//events
			{ "PropertyChanged", {{ "uint64_t", "???" }}, 7827212715229259961, AccessLevel::Public, Lua::StateContext::Client },
			{ "LuaPropertyChanged", {{ "std::string", "PropName" }}, 632871268461416663, AccessLevel::Public, Lua::StateContext::Client },
			{ "ChildAdded", {{ "Instance*", "Child" }}, 12382991221415885166, AccessLevel::Public, Lua::StateContext::Client },
			{ "ChildRemoved", {{ "Instance*", "Child" }}, 12241140569974167456, AccessLevel::Public, Lua::StateContext::Client },
			{ "DescendantAdded", {{ "Instance*", "Child" }, { "Instance*", "Parent" }}, 3535955318022864309, AccessLevel::Public, Lua::StateContext::Client },
			{ "DescendantRemoved", {{ "Instance*", "Child" }, { "Instance*", "Parent" }}, 17063255535271212331, AccessLevel::Public, Lua::StateContext::Client }
		},
		{
			//methods

		},
		::std::function<Instance * (Engine*)>(&instantiate_Instance),
		::std::function<::std::shared_ptr<Instance>(Engine*)>(&instantiateShared_Instance),
		{
			//public base classes

		},
		{
			//protected base classes

		},
		{
			//private base classes
16352485986006747530ULL
		},
		{
			//derived classes

		}
	};
}

#undef REFLECTION

//Class body macro (contains property hash ids)
#define REFLECTION() \
	using Base = BaseInstance<Instance>; \
public:\
	const static std::string& ClassName() { \
		static std::string _className = "Instance"; \
		return _className; \
	} \
	static Reflection::Class& StaticClass() { \
		 return Reflection::reflected_Instance; \
	} \
	struct ClassRegistrar { \
		template<typename T> \
		ClassRegistrar(T* inst) { \
			Reflection::TrySetClass(inst, &StaticClass()); \
		} \
	} _classRegistrar{this}; \
public: \
	static constexpr uint64_t prop_Id = 9675371895780238136ULL; \
	static constexpr uint64_t prop_Archivable = 14317038659104216526ULL; \
	static constexpr uint64_t prop_Name = 15240050715179114350ULL; \
	static constexpr uint64_t prop_Parent = 14850803764360279445ULL; \
	static constexpr uint64_t prop_Children = 9730800845107737082ULL; \
	static constexpr uint64_t event_PropertyChanged = 7827212715229259961ULL; \
	static constexpr uint64_t event_LuaPropertyChanged = 632871268461416663ULL; \
	static constexpr uint64_t event_ChildAdded = 12382991221415885166ULL; \
	static constexpr uint64_t event_ChildRemoved = 12241140569974167456ULL; \
	static constexpr uint64_t event_DescendantAdded = 3535955318022864309ULL; \
	static constexpr uint64_t event_DescendantRemoved = 17063255535271212331ULL; \
	static constexpr uint64_t method_GetPath = 891041929560864160ULL; \
	static constexpr uint64_t method_IsDescendantOf = 13558867208220020311ULL; \
	static constexpr uint64_t method_IsAncestorOf = 11886958722507655409ULL; \
	static constexpr uint64_t method_IsA = 17847601786295456764ULL; \
	static constexpr uint64_t method_GetDescendants = 13133224519907322337ULL; \
	static constexpr uint64_t method_SetClass = 11211909219713993813ULL; \
	static constexpr uint64_t method_SetParent = 1645709353750158059ULL; \
	static constexpr uint64_t method___onChildAdded = 9510136184764021638ULL; \
	static constexpr uint64_t method___onChildRemoved = 12103878991390214552ULL; \
	static constexpr uint64_t method___onDescendantAdded = 518019795190839949ULL; \
	static constexpr uint64_t method___onDescendantRemoved = 17085709999169637091ULL; \
	static constexpr uint64_t method___onParentChanged = 12096259620384440922ULL; \
	static constexpr uint64_t method___IsA = 1465893038046549154ULL; \
 \
	void raisePropChanged(uint64_t propId) { \
		PropertyChanged.Fire(propId); \
		if (LuaPropertyChanged.HasAnyListeners()) { \
			const std::string& propName = StaticClass().GetPropName(propId); \
			LuaPropertyChanged.Fire(propName); \
		} \
	} \
	const EngineUUID& GetId() const { return Id; } \
	void SetArchivable(bool value) { Archivable = value; raisePropChanged(prop_Archivable); } \
	bool GetArchivable() const { return Archivable; } \
	void SetName(const std::string& value) { Name = value; raisePropChanged(prop_Name); } \
	const std::string& GetName() const { return Name; } \
	Instance* GetParent() const { return Parent; } \
	const std::vector<Instance*>& GetChildren() const { return Children; } \
 \
private: \

#undef REFLECTION_END

//Macro that goes after the class definition, at the end of any header with reflected objects.
#define REFLECTION_END() \
namespace Reflection { \
	inline void wrap_Instance_SetParent(void* obj, void* value) { reinterpret_cast<Instance*>(obj)->SetParent(*reinterpret_cast<Instance**>(value)); } \
	/*ReadOnly setter*/ inline void wrap_Instance_SetId(void* obj, void* value) { throw std::runtime_error("Cannot set Instance.Id"); } \
	inline void* wrap_Instance_GetId(void* obj) { EngineUUID* value = &(reinterpret_cast<Instance*>(obj)->Id); return reinterpret_cast<void*>(value); } \
	inline void wrap_Instance_SetArchivable(void* obj, void* value) { Instance* instance = reinterpret_cast<Instance*>(obj); instance->Archivable = *reinterpret_cast<bool*>(value); instance->raisePropChanged(Instance::prop_Archivable); } \
	inline void* wrap_Instance_GetArchivable(void* obj) { bool* value = &(reinterpret_cast<Instance*>(obj)->Archivable); return reinterpret_cast<void*>(value); } \
	inline void wrap_Instance_SetName(void* obj, void* value) { Instance* instance = reinterpret_cast<Instance*>(obj); instance->Name = *reinterpret_cast<std::string*>(value); instance->raisePropChanged(Instance::prop_Name); } \
	inline void* wrap_Instance_GetName(void* obj) { std::string* value = &(reinterpret_cast<Instance*>(obj)->Name); return reinterpret_cast<void*>(value); } \
	inline void* wrap_Instance_GetParent(void* obj) { Instance** value = &(reinterpret_cast<Instance*>(obj)->Parent); return reinterpret_cast<void*>(value); } \
	/*ReadOnly setter*/ inline void wrap_Instance_SetChildren(void* obj, void* value) { throw std::runtime_error("Cannot set Instance.Children"); } \
	inline void* wrap_Instance_GetChildren(void* obj) { std::vector<Instance*>* value = &(reinterpret_cast<Instance*>(obj)->Children); return reinterpret_cast<void*>(value); } \
 \
	inline void register_Instance() { \
		Reflection::GetRegistry().classes.insert({ "Instance", &Reflection::reflected_Instance }); \
		Reflection::GetRegistry().classesById.insert({ 152245926312174492, &Reflection::reflected_Instance }); \
		reflected_Instance.ResolvePropSetter(Instance::prop_Parent, (void*)&wrap_Instance_SetParent); \
		reflected_Instance.ResolvePropSetter(Instance::prop_Id, (void*)&wrap_Instance_SetId); \
		reflected_Instance.ResolvePropGetter(Instance::prop_Id, (void*)&wrap_Instance_GetId); \
		reflected_Instance.ResolvePropSetter(Instance::prop_Archivable, (void*)&wrap_Instance_SetArchivable); \
		reflected_Instance.ResolvePropGetter(Instance::prop_Archivable, (void*)&wrap_Instance_GetArchivable); \
		reflected_Instance.ResolvePropSetter(Instance::prop_Name, (void*)&wrap_Instance_SetName); \
		reflected_Instance.ResolvePropGetter(Instance::prop_Name, (void*)&wrap_Instance_GetName); \
		reflected_Instance.ResolvePropGetter(Instance::prop_Parent, (void*)&wrap_Instance_GetParent); \
		reflected_Instance.ResolvePropSetter(Instance::prop_Children, (void*)&wrap_Instance_SetChildren); \
		reflected_Instance.ResolvePropGetter(Instance::prop_Children, (void*)&wrap_Instance_GetChildren); \
 \
	} \
	inline ::Instance* instantiate_Instance(Engine* engine) { \
		return (::Instance*)new Instance(engine); \
	} \
	inline ::std::shared_ptr<::Instance> instantiateShared_Instance(Engine* engine) { \
		return ::std::static_pointer_cast<::Instance>(::std::make_shared<Instance>(engine)); \
	} \
} \

