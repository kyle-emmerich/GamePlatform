//Autogenerated at 2025-12-10 18:22:25.116846
#pragma once
#include <typeinfo>
#include <memory>
#include <stdexcept>
#include "Instance/Reflection.h"

class System;
class Instance;
class Engine;


namespace Reflection {
	inline Instance* instantiate_RigidBody(Engine* engine);
	inline ::std::shared_ptr<Instance> instantiateShared_RigidBody(Engine* engine);


	//Class runtime reflection data
	inline static Class reflected_RigidBody = {
		//Class name
		"RigidBody",
		//Class hash id
		15834844444784614414,
		{
			//	Name, Type, Id, Flags, TypeFlags, Setter, Getter
			{ "Properties", "PhysicalProperties", 16562598759682906392, DefaultPropFlags, PropTypeFlags::None, AccessLevel::Public, Lua::StateContext::Client, nullptr, nullptr },
			{ "Inertia", "Math::Transform<double>", 10662476686257125261, PropFlags::ReadOnly, PropTypeFlags::None, AccessLevel::Public, Lua::StateContext::Client, nullptr, nullptr },
			{ "Velocity", "Math::Vector3<double>", 1318731205920430278, DefaultPropFlags, PropTypeFlags::None, AccessLevel::Public, Lua::StateContext::Client, nullptr, nullptr },
			{ "AngularVelocity", "Math::Vector3<double>", 15020630643522006634, DefaultPropFlags, PropTypeFlags::None, AccessLevel::Public, Lua::StateContext::Client, nullptr, nullptr }
		},
		{
			//events

		},
		{
			//methods

		},
		::std::function<Instance * (Engine*)>(&instantiate_RigidBody),
		::std::function<::std::shared_ptr<Instance>(Engine*)>(&instantiateShared_RigidBody),
		{
			//public base classes
152245926312174492ULL, 3592200817766671436ULL
		},
		{
			//protected base classes

		},
		{
			//private base classes

		},
		{
			//derived classes

		}
	};
}

#undef REFLECTION

//Class body macro (contains property hash ids)
#define REFLECTION() \
	using Base = Instance; \
public:\
	const static std::string& ClassName() { \
		static std::string _className = "RigidBody"; \
		return _className; \
	} \
	static Reflection::Class& StaticClass() { \
		 return Reflection::reflected_RigidBody; \
	} \
	struct ClassRegistrar { \
		template<typename T> \
		ClassRegistrar(T* inst) { \
			Reflection::TrySetClass(inst, &StaticClass()); \
		} \
	} _classRegistrar{this}; \
public: \
	static constexpr uint64_t prop_Properties = 16562598759682906392ULL; \
	static constexpr uint64_t prop_Inertia = 10662476686257125261ULL; \
	static constexpr uint64_t prop_Velocity = 1318731205920430278ULL; \
	static constexpr uint64_t prop_AngularVelocity = 15020630643522006634ULL; \
 \
	void raisePropChanged(uint64_t propId) { \
		PropertyChanged.Fire(propId); \
		if (LuaPropertyChanged.HasAnyListeners()) { \
			const std::string& propName = StaticClass().GetPropName(propId); \
			LuaPropertyChanged.Fire(propName); \
		} \
	} \
	void SetProperties(const PhysicalProperties& value) { Properties = value; raisePropChanged(prop_Properties); } \
	const PhysicalProperties& GetProperties() const { return Properties; } \
	const Math::Transform<double>& GetInertia() const { return Inertia; } \
	void SetVelocity(const Math::Vector3<double>& value) { Velocity = value; raisePropChanged(prop_Velocity); } \
	const Math::Vector3<double>& GetVelocity() const { return Velocity; } \
	void SetAngularVelocity(const Math::Vector3<double>& value) { AngularVelocity = value; raisePropChanged(prop_AngularVelocity); } \
	const Math::Vector3<double>& GetAngularVelocity() const { return AngularVelocity; } \
 \
private: \

#undef REFLECTION_END

//Macro that goes after the class definition, at the end of any header with reflected objects.
#define REFLECTION_END() \
namespace Reflection { \
	inline void wrap_RigidBody_SetProperties(void* obj, void* value) { RigidBody* instance = reinterpret_cast<RigidBody*>(obj); instance->Properties = *reinterpret_cast<PhysicalProperties*>(value); instance->raisePropChanged(RigidBody::prop_Properties); } \
	inline void* wrap_RigidBody_GetProperties(void* obj) { PhysicalProperties* value = &(reinterpret_cast<RigidBody*>(obj)->Properties); return reinterpret_cast<void*>(value); } \
	/*ReadOnly setter*/ inline void wrap_RigidBody_SetInertia(void* obj, void* value) { throw std::runtime_error("Cannot set RigidBody.Inertia"); } \
	inline void* wrap_RigidBody_GetInertia(void* obj) { Math::Transform<double>* value = &(reinterpret_cast<RigidBody*>(obj)->Inertia); return reinterpret_cast<void*>(value); } \
	inline void wrap_RigidBody_SetVelocity(void* obj, void* value) { RigidBody* instance = reinterpret_cast<RigidBody*>(obj); instance->Velocity = *reinterpret_cast<Math::Vector3<double>*>(value); instance->raisePropChanged(RigidBody::prop_Velocity); } \
	inline void* wrap_RigidBody_GetVelocity(void* obj) { Math::Vector3<double>* value = &(reinterpret_cast<RigidBody*>(obj)->Velocity); return reinterpret_cast<void*>(value); } \
	inline void wrap_RigidBody_SetAngularVelocity(void* obj, void* value) { RigidBody* instance = reinterpret_cast<RigidBody*>(obj); instance->AngularVelocity = *reinterpret_cast<Math::Vector3<double>*>(value); instance->raisePropChanged(RigidBody::prop_AngularVelocity); } \
	inline void* wrap_RigidBody_GetAngularVelocity(void* obj) { Math::Vector3<double>* value = &(reinterpret_cast<RigidBody*>(obj)->AngularVelocity); return reinterpret_cast<void*>(value); } \
 \
	inline void register_RigidBody() { \
		Reflection::GetRegistry().classes.insert({ "RigidBody", &Reflection::reflected_RigidBody }); \
		Reflection::GetRegistry().classesById.insert({ 15834844444784614414, &Reflection::reflected_RigidBody }); \
		reflected_RigidBody.ResolvePropSetter(RigidBody::prop_Properties, (void*)&wrap_RigidBody_SetProperties); \
		reflected_RigidBody.ResolvePropGetter(RigidBody::prop_Properties, (void*)&wrap_RigidBody_GetProperties); \
		reflected_RigidBody.ResolvePropSetter(RigidBody::prop_Inertia, (void*)&wrap_RigidBody_SetInertia); \
		reflected_RigidBody.ResolvePropGetter(RigidBody::prop_Inertia, (void*)&wrap_RigidBody_GetInertia); \
		reflected_RigidBody.ResolvePropSetter(RigidBody::prop_Velocity, (void*)&wrap_RigidBody_SetVelocity); \
		reflected_RigidBody.ResolvePropGetter(RigidBody::prop_Velocity, (void*)&wrap_RigidBody_GetVelocity); \
		reflected_RigidBody.ResolvePropSetter(RigidBody::prop_AngularVelocity, (void*)&wrap_RigidBody_SetAngularVelocity); \
		reflected_RigidBody.ResolvePropGetter(RigidBody::prop_AngularVelocity, (void*)&wrap_RigidBody_GetAngularVelocity); \
 \
	} \
	inline ::Instance* instantiate_RigidBody(Engine* engine) { \
		return (::Instance*)new RigidBody(engine); \
	} \
	inline ::std::shared_ptr<::Instance> instantiateShared_RigidBody(Engine* engine) { \
		return ::std::static_pointer_cast<::Instance>(::std::make_shared<RigidBody>(engine)); \
	} \
} \

